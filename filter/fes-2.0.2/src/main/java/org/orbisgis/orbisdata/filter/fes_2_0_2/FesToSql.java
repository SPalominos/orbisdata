/**
 * OrbisGIS is a java GIS application dedicated to research in GIScience.
 * OrbisGIS is developed by the GIS group of the DECIDE team of the
 * Lab-STICC CNRS laboratory, see <http://www.lab-sticc.fr/>.
 *
 * The GIS group of the DECIDE team is located at :
 *
 * Laboratoire Lab-STICC – CNRS UMR 6285
 * Equipe DECIDE
 * UNIVERSITÉ DE BRETAGNE-SUD
 * Institut Universitaire de Technologie de Vannes
 * 8, Rue Montaigne - BP 561 56017 Vannes Cedex
 *
 * OrbisGIS is distributed under GPL 3 license.
 *
 * Copyright (C) 2015-2017 CNRS (Lab-STICC UMR CNRS 6285)
 *
 * This file is part of OrbisGIS.
 *
 * OrbisGIS is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OrbisGIS is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OrbisGIS. If not, see <http://www.gnu.org/licenses/>.
 *
 * For more information, please consult: <http://www.orbisgis.org/>
 * or contact directly:
 * info_at_ orbisgis.org
 */
package org.orbisgis.orbisdata.filter.fes_2_0_2;

import net.opengis.fes._2_0_2.*;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import java.util.Iterator;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



/**
 * This class change a JaxB object in SQL parameter.
 * @Author Vincent QUILLIEN
 */
public class FesToSql {

    /** Logger instance. */
    private static Logger LOGGER = LoggerFactory.getLogger(FesToSql.class);

    /**
     * This method take an object generated by JaxB from a xml file and give un return the SQL parameter.
     *
     * @param objectFromFilterXml an object create by JaxB from a XML file.
     * @return the SQL parameter
     * @throws JAXBException
     */
    public static StringBuilder XmlToSql(Object objectFromFilterXml) {
        StringBuilder returnSQL = new StringBuilder();

        if (objectFromFilterXml != null) {
            if (objectFromFilterXml instanceof JAXBElement) {
                // first node : One branch for Filter and one for SortBy
                switch (((JAXBElement) objectFromFilterXml).getName().getLocalPart()) {

                    case "Filter":
                        FilterType filterType = (FilterType) ((JAXBElement) objectFromFilterXml).getValue();

                        if (filterType.isSetComparisonOps()) {
                            JAXBElement<ComparisonOpsType> comparisonElement = (JAXBElement<ComparisonOpsType>) filterType.getComparisonOps();
                            returnSQL.append(operatorComparison(comparisonElement));

                        } else if (filterType.isSetSpatialOps()) {
                            JAXBElement<SpatialOpsType> spatialElement = (JAXBElement<SpatialOpsType>) filterType.getSpatialOps();
                            returnSQL.append(operatorSpatial(spatialElement));

                        } else if (filterType.isSetLogicOps()) {
                            JAXBElement<LogicOpsType> logicalElement = (JAXBElement<LogicOpsType>) filterType.getLogicOps();
                            returnSQL.append(operatorLogical(logicalElement));

                        } else if (filterType.isSetFunction()) {
                            ObjectFactory factory = new ObjectFactory();
                            JAXBElement<FunctionType> functionElement = factory.createFunction(filterType.getFunction());
                            returnSQL.append(operatorFunction(functionElement));

                        } else if (filterType.isSetId()) {
                            // Not required at this time

                        } else if (filterType.isSetExtensionOps()) {
                            // Not required at this time

                        } else if (filterType.isSetTemporalOps()) {
                            // Not required at this time

                        }
                        break;
                    case "SortBy":
                        SortByType sortByType = (SortByType) ((JAXBElement) objectFromFilterXml).getValue();

                        if (sortByType.isSetSortProperty()) {
                            List<SortPropertyType> listProperty = sortByType.getSortProperty();
                            Iterator<SortPropertyType> listPropertyIterator = listProperty.iterator();

                            while (listPropertyIterator.hasNext()) {
                                SortPropertyType property = listPropertyIterator.next();

                                if (listPropertyIterator.hasNext() && property.isSetSortOrder()) {
                                    returnSQL.append(property.getValueReference());
                                    returnSQL.append(property.getSortOrder().value() + ", ");

                                } else if (listPropertyIterator.hasNext() && !(property.isSetSortOrder())) {
                                    returnSQL.append(property.getValueReference() + ", ");

                                } else if (!(listPropertyIterator.hasNext()) && (property.isSetSortOrder())) {
                                    returnSQL.append(property.getValueReference() + " ");
                                    returnSQL.append(property.getSortOrder());

                                } else {
                                    returnSQL.append(property.getValueReference());
                                }
                            }
                        } else {
                            LOGGER.warn("Warning : There aren't any property between the tag SortBy from the xml file ");
                        }
                        break;
                }
            } else {
                LOGGER.error("Error : Parameter objectFromFilterXml isn't an instance of JAXBElement");
            }
        } else {
            LOGGER.error("Error : Parameter objectFromFilterXml is null");
        }
        return returnSQL;
    }


//------------------------------------------------Operator Comparison-------------------------------------------------

    /**
     * Method separate the comparison object for each comparison operator
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorComparison(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();

        switch (comparisonElement.getName().getLocalPart()){
            case"PropertyIsBetween":
                returnSQL.append(operatorPropertyIsBetween(comparisonElement));
                break;

            case"PropertyIsLike":
                returnSQL.append(operatorPropertyIsLike(comparisonElement));
                break;

            case"PropertyIsNil":
                returnSQL.append(operatorPropertyIsNil(comparisonElement));
                break;

            case"PropertyIsNull":
                returnSQL.append(operatorPropertyIsNull(comparisonElement));
                break;

            default:
                returnSQL.append(operatorBinaryComparison(comparisonElement));
            break;
        }
        return returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsBetween
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorPropertyIsBetween(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsBetweenType propertyIsBetweenType = (PropertyIsBetweenType) comparisonElement.getValue();
        JAXBElement lowerBoundary = propertyIsBetweenType.getLowerBoundary().getExpression();
        JAXBElement upperBoundary = propertyIsBetweenType.getUpperBoundary().getExpression();

        if (propertyIsBetweenType.isSetExpression()) {
            returnSQL.append(getExpressionRecursive(propertyIsBetweenType.getExpression()));
            returnSQL.append("BETWEEN ");

            if (propertyIsBetweenType.isSetLowerBoundary()) {
                returnSQL.append(getExpressionRecursive(lowerBoundary));
            }else {
                returnSQL.append("   ");
            }
            if (propertyIsBetweenType.isSetUpperBoundary()) {
                returnSQL.append(getExpressionRecursive(upperBoundary));
            }else {
                returnSQL.append("   ");
            }

        } else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsLike
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorPropertyIsLike(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsLikeType propertyIsLikeType = (PropertyIsLikeType) comparisonElement.getValue();
        if (propertyIsLikeType.isSetExpression()) {
            List<JAXBElement<?>> list = propertyIsLikeType.getExpression();

            for (JAXBElement element : list) {
                returnSQL.append(getExpressionRecursive(element));

                if (list.get(0) == element) {
                    returnSQL.append("LIKE ");
                }
            }
        }else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsNil
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorPropertyIsNil(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsNilType propertyIsNilType = (PropertyIsNilType) comparisonElement.getValue();

        if (propertyIsNilType.isSetExpression()) {
            returnSQL.append(getExpressionRecursive(propertyIsNilType.getExpression()));
            returnSQL.append("IS NIL");
        }else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsNull
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorPropertyIsNull(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsNullType propertyIsNullType = (PropertyIsNullType) comparisonElement.getValue();

        if (propertyIsNullType.isSetExpression()) {
            returnSQL.append(getExpressionRecursive(propertyIsNullType.getExpression()));
            returnSQL.append("IS NULL");
        }else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type BinaryComparison
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorBinaryComparison(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        //type BinaryComparisonOpType
        BinaryComparisonOpType binaryComparisonOpType = (BinaryComparisonOpType) comparisonElement.getValue();

        if (binaryComparisonOpType.isSetExpression()) {
            List<JAXBElement<?>> list = binaryComparisonOpType.getExpression();

            for (JAXBElement element : list) {
                returnSQL.append(getExpressionRecursive(element));

                if (list.get(0) == element) {

                    switch (comparisonElement.getName().getLocalPart()) {
                        case "PropertyIsGreaterThan":
                            returnSQL.append("> ");
                            break;
                        case "PropertyIsLessThan":
                            returnSQL.append("< ");
                            break;
                        case "PropertyIsEqualTo":
                            returnSQL.append("= ");
                            break;
                        case "PropertyIsNotEqualTo":
                            returnSQL.append("!= ");
                            break;
                        case "PropertyIsLessThanOrEqualTo":
                            returnSQL.append("<= ");
                            break;
                        case "PropertyIsGreaterThanOrEqualTo":
                            returnSQL.append(">= ");
                            break;
                    }
                }
            }
        }else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }


//-----------------------------------------------Operator Spatial-------------------------------------------------------

    /**
     * Method separate the Spatial object for each Spatial Operator
     * @param spatialElement a JaxbElement object , this object have a characteristic type : SpatialOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorSpatial(JAXBElement<SpatialOpsType> spatialElement){
        StringBuilder returnSQL = new StringBuilder();
        // not implemented yet
        return  returnSQL;
    }

//------------------------------------------------Operator Logical------------------------------------------------------

    /**
     * Method separate the Logical object for each Spatial Logical
     * @param logicalElement a JaxbElement object , this object have a characteristic type : LogicOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorLogical(JAXBElement<LogicOpsType> logicalElement){
        StringBuilder returnSQL = new StringBuilder();
        // not implemented yet
        return  returnSQL;
    }

//-----------------------------------------------Operator Function------------------------------------------------------

    /**
     * Method create the String returned for the object of type Function. Used the Method getExpressionRecursive
     * because an expression can be a function.
     * @param functionElement a JaxbElement object , this object have a characteristic type : FunctionType
     * @return the SQL parameter
     */
    private static StringBuilder operatorFunction(JAXBElement<FunctionType> functionElement){
        StringBuilder returnSQL = new StringBuilder();
        returnSQL.append(getExpressionRecursive(functionElement));
        returnSQL.append(")");
        return  returnSQL;
    }

//----------------------------------------------------Expression--------------------------------------------------------

    /**
     * Method create the String returned for the expression : These types can be Function, ValueReference, Literal and Object.
     * @param element a JaxbElement object
     * @return the SQL parameter
     */
    private static StringBuilder getExpressionRecursive(JAXBElement element){
        StringBuilder stringBuilder = new StringBuilder();

        switch (element.getName().getLocalPart()){
            case"Function":
                FunctionType functionType = (FunctionType) element.getValue();
                stringBuilder.append(functionType.getName()+"( ");

                List<JAXBElement<?>> listExpression = functionType.getExpression();
                for(JAXBElement exp : listExpression){

                    stringBuilder.append(getExpressionRecursive(exp));

                    if (listExpression.get((listExpression.size()-1)) != exp) {
                        stringBuilder.append(", ");
                    }
                }
                break;
            case"ValueReference":
                stringBuilder.append(element.getValue().toString()+" ");
                break;
            case "Literal":
                LiteralType literalType = ((JAXBElement<LiteralType>)element).getValue();
                List list = literalType.getContent();

                for(Object obj : list){
                    stringBuilder.append(obj.toString()+" ");
                }
                break;
            default:
                LOGGER.error("Error : Unrecognized object in the expression");
        }

        return stringBuilder;
    }
}