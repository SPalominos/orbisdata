/**
 * OrbisGIS is a java GIS application dedicated to research in GIScience.
 * OrbisGIS is developed by the GIS group of the DECIDE team of the
 * Lab-STICC CNRS laboratory, see <http://www.lab-sticc.fr/>.
 *
 * The GIS group of the DECIDE team is located at :
 *
 * Laboratoire Lab-STICC – CNRS UMR 6285
 * Equipe DECIDE
 * UNIVERSITÉ DE BRETAGNE-SUD
 * Institut Universitaire de Technologie de Vannes
 * 8, Rue Montaigne - BP 561 56017 Vannes Cedex
 *
 * OrbisGIS is distributed under GPL 3 license.
 *
 * Copyright (C) 2015-2017 CNRS (Lab-STICC UMR CNRS 6285)
 *
 * This file is part of OrbisGIS.
 *
 * OrbisGIS is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * OrbisGIS is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * OrbisGIS. If not, see <http://www.gnu.org/licenses/>.
 *
 * For more information, please consult: <http://www.orbisgis.org/>
 * or contact directly:
 * info_at_ orbisgis.org
 */
package org.orbisgis.orbisdata.filter.fes_2_0_2;

import net.opengis.fes._2_0_2.*;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import java.util.Iterator;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;



/**
 * This class change a JaxB object in SQL parameter.
 * @Author Vincent QUILLIEN
 */
public class FesToSql {

    /** Logger instance. */
    private static Logger LOGGER = LoggerFactory.getLogger(FesToSql.class);

    /**
     * This method take an object generated by JaxB from a xml file and give un return the SQL parameter.
     * If there are a problem with the parameter object of Xml, the returnSql will be empty.
     *
     * @param objectFromFilterXml an object create by JaxB from a XML file.
     * @return the SQL parameter
     * @throws JAXBException
     */
    public static StringBuilder XmlToSql(Object objectFromFilterXml) {
        StringBuilder returnSQL = new StringBuilder();

        if (objectFromFilterXml != null) {
            if (objectFromFilterXml instanceof JAXBElement) {
                // first node : One branch for Filter and one for SortBy
                switch (((JAXBElement) objectFromFilterXml).getName().getLocalPart()) {

                    case "Filter":
                        FilterType filterType = (FilterType) ((JAXBElement) objectFromFilterXml).getValue();

                        if (filterType.isSetComparisonOps()) {
                            JAXBElement<ComparisonOpsType> comparisonElement = (JAXBElement<ComparisonOpsType>) filterType.getComparisonOps();
                            returnSQL.append(operatorComparison(comparisonElement));

                        } else if (filterType.isSetSpatialOps()) {
                            JAXBElement<SpatialOpsType> spatialElement = (JAXBElement<SpatialOpsType>) filterType.getSpatialOps();
                            returnSQL.append(operatorSpatial(spatialElement));

                        } else if (filterType.isSetLogicOps()) {
                            JAXBElement<LogicOpsType> logicalElement = (JAXBElement<LogicOpsType>) filterType.getLogicOps();
                            returnSQL.append(operatorLogical(logicalElement));

                        } else if (filterType.isSetFunction()) {
                            ObjectFactory factory = new ObjectFactory();
                            JAXBElement<FunctionType> functionElement = factory.createFunction(filterType.getFunction());
                            returnSQL.append(operatorFunction(functionElement));

                        } else if (filterType.isSetId()) {
                            // Not required at this time

                        } else if (filterType.isSetExtensionOps()) {
                            // Not required at this time

                        } else if (filterType.isSetTemporalOps()) {
                            // Not required at this time

                        }
                        break;
                    case "SortBy":
                        SortByType sortByType = (SortByType) ((JAXBElement) objectFromFilterXml).getValue();

                        if (sortByType.isSetSortProperty()) {
                            List<SortPropertyType> listProperty = sortByType.getSortProperty();
                            Iterator<SortPropertyType> listPropertyIterator = listProperty.iterator();

                            while (listPropertyIterator.hasNext()) {
                                SortPropertyType property = listPropertyIterator.next();

                                if (listPropertyIterator.hasNext() && property.isSetSortOrder()) {
                                    returnSQL.append(property.getValueReference());
                                    returnSQL.append(property.getSortOrder().value() + ", ");

                                } else if (listPropertyIterator.hasNext() && !(property.isSetSortOrder())) {
                                    returnSQL.append(property.getValueReference() + ", ");

                                } else if (!(listPropertyIterator.hasNext()) && (property.isSetSortOrder())) {
                                    returnSQL.append(property.getValueReference() + " ");
                                    returnSQL.append(property.getSortOrder());

                                } else {
                                    returnSQL.append(property.getValueReference());
                                }
                            }
                        } else {
                            LOGGER.warn("Warning : There aren't any property between the tag SortBy from the xml file ");
                        }
                        break;
                }
            } else {
                LOGGER.error("Error : Parameter objectFromFilterXml isn't an instance of JAXBElement");
            }
        } else {
            LOGGER.error("Error : Parameter objectFromFilterXml is null");
        }
        return returnSQL;
    }


//------------------------------------------------Operator Comparison-------------------------------------------------

    /**
     * Method separate the comparison object for each comparison operator
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorComparison(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();

        switch (comparisonElement.getName().getLocalPart()){
            case"PropertyIsBetween":
                returnSQL.append(operatorPropertyIsBetween(comparisonElement));
                break;

            case"PropertyIsLike":
                returnSQL.append(operatorPropertyIsLike(comparisonElement));
                break;

            case"PropertyIsNil":
                returnSQL.append(operatorPropertyIsNil(comparisonElement));
                break;

            case"PropertyIsNull":
                returnSQL.append(operatorPropertyIsNull(comparisonElement));
                break;

            default:
                returnSQL.append(operatorBinaryComparison(comparisonElement));
                break;
        }
        return returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsBetween
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorPropertyIsBetween(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsBetweenType propertyIsBetweenType = (PropertyIsBetweenType) comparisonElement.getValue();
        JAXBElement lowerBoundary = propertyIsBetweenType.getLowerBoundary().getExpression();
        JAXBElement upperBoundary = propertyIsBetweenType.getUpperBoundary().getExpression();

        if (propertyIsBetweenType.isSetExpression()) {
            returnSQL.append(getExpressionRecursive(propertyIsBetweenType.getExpression()));
            returnSQL.append("BETWEEN ");

            if (propertyIsBetweenType.isSetLowerBoundary()) {
                returnSQL.append(getExpressionRecursive(lowerBoundary));
            }else {
                returnSQL.append("   ");
            }
            if (propertyIsBetweenType.isSetUpperBoundary()) {
                returnSQL.append(getExpressionRecursive(upperBoundary));
            }else {
                returnSQL.append("   ");
            }

        } else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsLike
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorPropertyIsLike(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsLikeType propertyIsLikeType = (PropertyIsLikeType) comparisonElement.getValue();
        if (propertyIsLikeType.isSetExpression()) {
            List<JAXBElement<?>> list = propertyIsLikeType.getExpression();

            for (JAXBElement element : list) {
                returnSQL.append(getExpressionRecursive(element));

                if (list.get(0) == element) {
                    returnSQL.append("LIKE ");
                }
            }
        }else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsNil
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorPropertyIsNil(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsNilType propertyIsNilType = (PropertyIsNilType) comparisonElement.getValue();

        if (propertyIsNilType.isSetExpression()) {
            returnSQL.append(getExpressionRecursive(propertyIsNilType.getExpression()));
            returnSQL.append("IS NULL");
        }else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type PropertyIsNull
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorPropertyIsNull(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        PropertyIsNullType propertyIsNullType = (PropertyIsNullType) comparisonElement.getValue();

        if (propertyIsNullType.isSetExpression()) {
            returnSQL.append(getExpressionRecursive(propertyIsNullType.getExpression()));
            returnSQL.append("IS NULL");
        }else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }

    /**
     * Method create the String returned for the object of type BinaryComparison
     * @param comparisonElement a JaxbElement object , this object have a characteristic type : ComparisonOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorBinaryComparison(JAXBElement<ComparisonOpsType> comparisonElement){
        StringBuilder returnSQL = new StringBuilder();
        //type BinaryComparisonOpType
        BinaryComparisonOpType binaryComparisonOpType = (BinaryComparisonOpType) comparisonElement.getValue();

        if (binaryComparisonOpType.isSetExpression()) {
            List<JAXBElement<?>> list = binaryComparisonOpType.getExpression();

            for (JAXBElement element : list) {
                returnSQL.append(getExpressionRecursive(element));

                if (list.get(0) == element) {

                    switch (comparisonElement.getName().getLocalPart()) {
                        case "PropertyIsGreaterThan":
                            returnSQL.append("> ");
                            break;
                        case "PropertyIsLessThan":
                            returnSQL.append("< ");
                            break;
                        case "PropertyIsEqualTo":
                            returnSQL.append("= ");
                            break;
                        case "PropertyIsNotEqualTo":
                            returnSQL.append("!= ");
                            break;
                        case "PropertyIsLessThanOrEqualTo":
                            returnSQL.append("<= ");
                            break;
                        case "PropertyIsGreaterThanOrEqualTo":
                            returnSQL.append(">= ");
                            break;
                    }
                }
            }
        }else {
            LOGGER.warn("Warning: Input expression is not set");
        }
        return  returnSQL;
    }


//-----------------------------------------------Operator Spatial-------------------------------------------------------

    /**
     * Method separate the Spatial object for each Spatial Operator
     * @param spatialElement a JaxbElement object , this object have a characteristic type : SpatialOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorSpatial(JAXBElement<SpatialOpsType> spatialElement){
        StringBuilder returnSQL = new StringBuilder();

        switch (spatialElement.getName().getLocalPart()){
            case"BBOX":
                BBOXType bbox = (BBOXType) spatialElement.getValue();
                if (bbox.isSetExpressionOrAny()) {
                    returnSQL.append(operatorBBOX(bbox));
                }else {
                    LOGGER.warn("Warning: Input expression or any object is not set");
                }
                break;
            case "DWithin":
                DistanceBufferType distanceBuffer = (DistanceBufferType) spatialElement.getValue();
                if(distanceBuffer.isSetExpressionOrAny()){
                    returnSQL.append(operatorDWithin(distanceBuffer));
                }else {
                    LOGGER.warn("Warning: Input expression or any object is not set");
                }
                break;
            default:
                BinarySpatialOpType binarySpatialOp = (BinarySpatialOpType) spatialElement.getValue();
                if (binarySpatialOp.isSetExpressionOrAny()) {
                    returnSQL.append(operatorBinarySpatial(binarySpatialOp, spatialElement));
                }else {
                    LOGGER.warn("Warning: Input expression or any object is not set");
                }
                break;
        }
        return  returnSQL;
    }


    /**
     * Method create the String returned for the object type BBOX. This operator can be transform in a two function,
     * a not and a Disjoint.
     * @param bboxType a BBOXType object
     * @return the SQL parameter
     */
    private static StringBuilder operatorBBOX( BBOXType bboxType) {
        StringBuilder returnSQL = new StringBuilder();
        returnSQL.append("NOT ST_Disjoint( ");
        List<Object> list = bboxType.getExpressionOrAny();
        for (Object obj : list) {
            if (obj instanceof JAXBElement) {
                returnSQL.append(getExpressionRecursive((JAXBElement) obj));
            } else {
                LOGGER.error("Error: the object is not an instance of JaxBElement");
            }
            if(list.get((list.size()-1))!=obj)returnSQL.append(", ");
        }
        returnSQL.append(")");
        return returnSQL;
    }


    /**
     * Method create the String returned for the object of type DWithin
     * @param distanceBuffer a DistanceBufferType object
     * @return the SQL parameter
     */
    private static StringBuilder operatorDWithin(DistanceBufferType distanceBuffer) {
        StringBuilder returnSQL = new StringBuilder();
        List<Object> list = distanceBuffer.getExpressionOrAny();
        returnSQL.append("ST_DWithin( ");
        for (Object obj : list) {
            if (obj instanceof JAXBElement) {
                JAXBElement element = ((JAXBElement) obj);
                returnSQL.append(getExpressionRecursive(element));
                returnSQL.append(", ");
            }else {
                LOGGER.error("Error: the object is not an instance of JaxBElement");
            }
        }
        returnSQL.append(distanceBuffer.getDistance().getValue()+" ");
        returnSQL.append(")");
        return returnSQL;
    }

    /**
     * Method create the String returned for the object of type BinarySpatialOp
     * @param binarySpatialOp a BinarySpatialOpType object
     * @param spatialElement a JaxbElement object , this object have a characteristic type : BBOXType
     * @return a StringBuilder
     */
    private static StringBuilder operatorBinarySpatial(BinarySpatialOpType binarySpatialOp,JAXBElement<SpatialOpsType> spatialElement ) {
        StringBuilder returnSQL = new StringBuilder();
        List<Object> list = binarySpatialOp.getExpressionOrAny();

        for (Object obj : list) {
            if (obj instanceof JAXBElement) {

                if(list.get(0).equals(obj)) {
                    switch (spatialElement.getName().getLocalPart()) {
                        case "Equals":
                            returnSQL.append("ST_Equals( ");
                            break;
                        case "Disjoint":
                            returnSQL.append("ST_Disjoint( ");
                            break;
                        case "Touches":
                            returnSQL.append("ST_Touches( ");
                            break;
                        case "Overlaps":
                            returnSQL.append("ST_Overlaps( ");
                            break;
                        case "Crosses":
                            returnSQL.append("ST_Crosses( ");
                            break;
                        case "Intersects":
                            returnSQL.append("ST_Intersects( ");
                            break;
                        case "Contains":
                            returnSQL.append("ST_Contains( ");
                            break;
                        case "Within":
                            returnSQL.append("ST_Within( ");
                            break;
                    }
                }

                JAXBElement element = ((JAXBElement) obj);
                returnSQL.append(getExpressionRecursive(element));

                if(list.get((list.size()-1))!=obj){
                    returnSQL.append(", ");
                }

            } else {
                LOGGER.error("Error: the object is not an instance of JaxBElement");
            }
        }
        returnSQL.append(")");
        return returnSQL;
    }

//------------------------------------------------Operator Logical------------------------------------------------------

    /**
     * Method separate the Logical object for each Spatial Logical
     * @param logicalElement a JaxbElement object , this object have a characteristic type : LogicOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorLogical(JAXBElement<LogicOpsType> logicalElement){
        StringBuilder returnSQL = new StringBuilder();
        switch (logicalElement.getName().getLocalPart()){
            case"Not":
                returnSQL.append(operatorNot(logicalElement));
                break;
            default:
                BinaryLogicOpType binaryLogicOpType = (BinaryLogicOpType) logicalElement.getValue();
                String ops = logicalElement.getName().getLocalPart();
                returnSQL.append(operatorOrAnd(binaryLogicOpType,ops));
                break;
        }
        return  returnSQL;
    }


    /**
     * Method create the String returned for the object of type UnaryLogic
     * @param logicalElement a JaxbElement object , this object have a characteristic type : LogicOpsType
     * @return the SQL parameter
     */
    private static StringBuilder operatorNot(JAXBElement<LogicOpsType> logicalElement){
        StringBuilder returnSQL = new StringBuilder();
        UnaryLogicOpType unaryLogic = (UnaryLogicOpType) logicalElement.getValue();
        returnSQL.append("!( ");

        if (unaryLogic.isSetComparisonOps()) {
            JAXBElement<ComparisonOpsType> comparisonElement = (JAXBElement<ComparisonOpsType>) unaryLogic.getComparisonOps();
            returnSQL.append(operatorComparison(comparisonElement));

        } else if (unaryLogic.isSetSpatialOps()) {
            JAXBElement<SpatialOpsType> spatialElement = (JAXBElement<SpatialOpsType>) unaryLogic.getSpatialOps();
            returnSQL.append(operatorSpatial(spatialElement));

        } else if (unaryLogic.isSetLogicOps()) {
            JAXBElement<LogicOpsType> logicalElementRecursif = (JAXBElement<LogicOpsType>) unaryLogic.getLogicOps();
            returnSQL.append(operatorLogical(logicalElementRecursif));//

        } else if (unaryLogic.isSetFunction()) {
            ObjectFactory factory = new ObjectFactory();
            JAXBElement<FunctionType> functionElement = factory.createFunction(unaryLogic.getFunction());
            returnSQL.append(operatorFunction(functionElement));

        } else if (unaryLogic.isSetId()) {
            // Not required at this time

        } else if (unaryLogic.isSetExtensionOps()) {
            // Not required at this time

        } else if (unaryLogic.isSetTemporalOps()) {
            // Not required at this time
        }
        returnSQL.append(") ");
        return returnSQL ;
    }

    /**
     * Method create the String returned for the object of type BinaryLogic
     * @param binaryLogicOpType a JaxbElement object , this object have a characteristic type : LogicOpsType
     * @param ops the name of the operator
     * @return the SQL parameter
     */
    private static StringBuilder operatorOrAnd(BinaryLogicOpType binaryLogicOpType,String ops) {
        StringBuilder returnSQL = new StringBuilder();

        if (binaryLogicOpType.isSetComparisonOpsOrSpatialOpsOrTemporalOps()) {
            returnSQL.append("( ");
            List<JAXBElement<?>> list = binaryLogicOpType.getComparisonOpsOrSpatialOpsOrTemporalOps();
            for (JAXBElement element : list) {

                if(element==list.get((list.size()-1))){
                    returnSQL.append(ops+" ");
                }

                if(element.getValue() instanceof ComparisonOpsType){
                    returnSQL.append(operatorComparison(element));

                }else if(element.getValue() instanceof SpatialOpsType){
                    returnSQL.append(operatorSpatial(element));

                }else if(element.getValue() instanceof LogicOpsType){
                    returnSQL.append(operatorLogical(element));

                }else if(element.getValue() instanceof FunctionType){
                    returnSQL.append(operatorFunction(element));

                }else if(element.getValue() instanceof ExtensionOpsType){
                    // Not required at this time

                }else if(element.getValue() instanceof ResourceIdType){
                    // Not required at this time

                }else if(element.getValue() instanceof TemporalOpsType){
                    // Not required at this time
                }
            }
            returnSQL.append(") ");
        }
        return returnSQL;
    }

//-----------------------------------------------Operator Function------------------------------------------------------

    /**
     * Method create the String returned for the object of type Function. Used the Method getExpressionRecursive
     * because an expression can be a function.
     * @param functionElement a JaxbElement object , this object have a characteristic type : FunctionType
     * @return the SQL parameter
     */
    private static StringBuilder operatorFunction(JAXBElement<FunctionType> functionElement){
        StringBuilder returnSQL = new StringBuilder();
        returnSQL.append(getExpressionRecursive(functionElement));
        returnSQL.append(")");
        return  returnSQL;
    }

//----------------------------------------------------Expression--------------------------------------------------------

    /**
     * Method create the String returned for the expression : These types can be Function, ValueReference, Literal and Object.
     * @param element a JaxbElement object
     * @return the SQL parameter
     */
    private static StringBuilder getExpressionRecursive(JAXBElement element){
        StringBuilder stringBuilder = new StringBuilder();

        switch (element.getName().getLocalPart()){
            case"Function":
                FunctionType functionType = (FunctionType) element.getValue();
                stringBuilder.append(functionType.getName()+"( ");

                List<JAXBElement<?>> listExpression = functionType.getExpression();
                for(JAXBElement exp : listExpression){

                    stringBuilder.append(getExpressionRecursive(exp));

                    if (listExpression.get((listExpression.size()-1)) != exp) {
                        stringBuilder.append(", ");
                    }
                }
                break;
            case"ValueReference":
                stringBuilder.append(element.getValue().toString()+" ");
                break;
            case "Literal":
                LiteralType literalType = ((JAXBElement<LiteralType>)element).getValue();
                List list = literalType.getContent();

                for(Object obj : list){
                    stringBuilder.append(obj.toString()+" ");
                }
                break;
            default:
                LOGGER.error("Error : Unrecognized object in the expression");
        }

        return stringBuilder;
    }
}